---
title: "Introduction to inequantiles: Quantile-Based Inequality Measures for Survey Data"
author: "Silvia Scarpa"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to inequantiles: Quantile-Based Inequality Measures for Survey Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib
---



```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

# Overview

The **inequantiles** package provides tools for estimating quantiles and quantile-based inequality indicators from survey data, with full support for complex sampling designs. These indicators offer robust alternatives to traditional moment-based measures like the Gini coefficient, particularly for skewed distributions with heavy tails.

## Key Features

- **Quantile ratio index (QRI)**: An inequality measure based on ratios of symmetric quantiles and considering the whole distribution
- **Traditional indicators**: Quintile share ratio (QSR), Palma ratio, percentile ratios (e.g., P90/P10) estimators
- **Weighted quantile estimation**: Multiple interpolation rules (types 4-9 plus HD) for the estimation of quantiles on complex sampling data
- **Variance estimation**: Rescaled bootstrap methods for complex surveys 
- **Linearization techniques**: Influence function for the QRI, QSR, Gini and quantiles
- **Grouped data support**: Estimation of quantiles, the QRI and the Gini coefficient from frequency tables and grouped data when microdata are unavailable

## Installation

```{r, eval = FALSE}
# Install from GitHub
devtools::install_github("silviascarpa/inequantiles")
```

```{r}
library(inequantiles)
```


## Import synthetic survey data
```{r}
data(synthouse)
head(synthouse)
```

# Theoretical Background

## The Quantile Ratio Index (QRI)

The QRI was introduced by \insertCite{prendergast2018simple;textual}{inequantiles} as a simple, interpretable inequality measure. The QRI:

- Considers the entire distribution
- Depends solely on quantiles
- Is robust to extreme values
- Does not require choosing specific percentiles

### Definition

For a continuous random variable $Y$ with cdf $F(y)$ and quantile function $Q(p) = F^{-1}(p)$, define the ratio between symmetric quantiles as:

$$R(p) = \frac{Q(p/2)}{Q(1-p/2)}, \quad p \in (0,1)$$

The QRI is then defined as:

$$\text{QRI} = 1 - \int_0^1 R(p) \, dp = 1 - \int_0^1 \frac{Q(p/2)}{Q(1-p/2)} \, dp$$

The QRI ranges from 0 (perfect equality) to 1 (maximum inequality). It measures the area between the equi-distribution line ($R(p) = 1$ for all $p$) and the actual inequality curve.

For theoretical distributions with known quantile functions, you can compute the exact QRI:

```{r}
# Log-normal distribution
superpop_qri(qlnorm, meanlog = 9, sdlog = 0.3)
superpop_qri(qlnorm, meanlog = 9, sdlog = 0.7)
superpop_qri(qlnorm, meanlog = 9, sdlog = 1.2)

# Weibull distribution
superpop_qri(qweibull, shape = 2, scale = 30000)
superpop_qri(qweibull, shape = 1.5, scale = 30000)
```


### Finite Population framework
Consider a finite population $U = \{1, \ldots, N}$, from which a random sample $s$ of size $n$ is selected. Let $y_j$, $j \in s$, be the observed values of the variable of interest, with $y_{(1)}, \ldots, y_{(n)}$ denoting its order statistics. Assume that the sample is drawn according to a certain sampling scheme, with inclusion probability $\pi_j = Pr(j \in s)$. The corresponding sampling weight $w_j$ is obtained by the inversion of the inclusion probability, plus, when required, some adjustments for non-response and calibration.  Let $W_j = \sum_{i \in s} w_i \mathbf{1}(i \leq j)$ denote the cumulative sum of weights up to observation $j$. For $p=0$ and $p=1$, define $\widehat{Q} (0)=y_{(1)}$ and $\widehat{Q}(1)=y_{(n)}$. The $p$ quantile estimator can be expressed as a weighted average of order statistics, 

$$
\widehat{Q}(p)=y_{(k-1)}+ \left(y_{(k )} - y_{(k- 1)}\right) \left(\frac{p - \widehat{r}_{k - 1 }}{\widehat{r}_{k} - \widehat{r}_{k - 1}} \right),
\label{eq:quantiles complessi}
$$

where $\widehat{r}_{k}$ indicates the estimator of the cdf, namely the plotting position, and the selected order $k$ is such that $W_{k-1} - m_{k-1} < W_n p < W_{k} - m_k$, where $m_k$ is determined by the interpolation method between adjacent data points.
Linear interpolation between the points $(\widehat r, y_{(k)})$ gives a quantile estimator for complex sampling data.

The `csquantile()` function extends standard quantile estimation to survey data with weights. It implements the methods described in \insertCite{hyndman1996sample;textual}{inequantiles} adapted for weighted data, plus the Harrell-Davis estimator.

### Example: Computing Weighted Quantiles

```{r}
# Compute weighted quartiles
csquantile(y = synthouse$eq_income,
           weights = synthouse$weight,
           probs = c(0.25, 0.5, 0.75),
           type = 6)

# Compare with unweighted
csquantile(synthouse$eq_income, probs = c(0.25, 0.5, 0.75), type = 6)
```

### Harrell-Davis Estimator

The Harrell-Davis estimator \insertCite{harrell1982new}{inequantiles} uses a weighted average of all order statistics:

```{r}
# Harrell-Davis weighted median
csquantile(y = synthouse$eq_income,
           weights = synthouse$weight,
           probs = 0.5,
           type = "HD")
```


## QRI estimator
For survey data from a finite population, we approximate the QRI integral using a grid of $M$ points:

$$
\widehat{\text{QRI}} = \frac{1}{M} \sum_{m=1}^M \left(1 - \frac{\widehat{Q}(p_m/2)}{\widehat{Q}(1-p_m/2)}\right)
$$

where $p_m = (m-0.5)/M$ and $\widehat{Q}(p)$ is a weighted sample quantile. By default, $M = 100$.

When the sample is drawn with a simple random sampling design, the QRI can be easily estimated as

```{r}
# Generate a simple random sample of income data (log-normal distribution)
set.seed(123)
income <- rlnorm(500, meanlog = 9, sdlog = 0.7)


# Compute QRI
qri(income)
```


Real survey data, instead, typically includes sampling weights (see `synthouse` as an example of survey data, here created synthetically for examples):

```{r}

# Compute weighted QRI
qri(y = synthouse$eq_income, 
    weights = synthouse$weight, 
    type = 6)  # Type 6 quantile estimator (default)
```

## Comparing Different Quantile Types

The package supports multiple quantile estimation methods (types 4-9 and Harrell-Davis) into quantile-based inequality indicators estimators. Differences are particularly evident in small samples \insertCite{scarpa2025inference}{inequantiles}:

```{r}
# Compare different quantile types by NUTS3
types <- c(4, 5, 6, 7, 8, 9, "HD")
areas <- unique(synthouse$NUTS3)

# Function to compute QRI for all types in one region
compare_types_region <- function(region_code, data = synthouse) {
  idx <- which(data$NUTS3 == region_code)
  
  results <- sapply(types, function(t) {
    qri(y = data$eq_income[idx], 
        weights = data$weight[idx], 
        type = t)
  })
  
  return(results)
}

# Compute for all areas
results_matrix <- sapply(areas, compare_types_region)
rownames(results_matrix) <- types
colnames(results_matrix) <- areas

# Convert to readable data frame
results_df <- as.data.frame(t(results_matrix))
results_df <- round(results_df, 4)
results_df <- cbind(NUTS3 = rownames(results_df), results_df)
rownames(results_df) <- NULL

print("=== QRI by Quantile Type for Each NUTS3 Region ===")
print(head(results_df, n = 10))
```


# Other Inequality Indicators

## Quintile Share Ratio (QSR)

The QSR compares the income share of the top 20% to the bottom 20%:

$$
\text{QSR} = \frac{\sum_{i: y_i \geq Q(0.8)} w_i y_i}{\sum_{i: y_i \leq Q(0.2)} w_i y_i}
$$

```{r}
# Compute QSR
qsr(y = synthouse$eq_income, 
    weights = synthouse$weight, type = 4)
```

## Palma Ratio

The Palma ratio compares the top 10% to the bottom 40%:

```{r}
# Compute Palma ratio
palma_ratio(y = synthouse$eq_income, 
            weights = synthouse$weight, type = 7)
```

## Percentile Ratios (e.g., P90/P10)

```{r}
# P90/P10 ratio
ratio_quantiles(y = synthouse$eq_income,
                weights = synthouse$weight,
                prob_numerator = 0.90,
                prob_denominator = 0.10,
                type = 7)

# P75/P25 ratio
ratio_quantiles(y = synthouse$eq_income,
                weights = synthouse$weight,
                prob_numerator = 0.75,
                prob_denominator = 0.25, type = 6)
```

# Comparing Indicators Across Groups

A common task is comparing inequality across geographical areas or demographic groups:

```{r}
# Compare QRI across macro-regions (NUTS1)
tapply(seq_len(nrow(synthouse)), synthouse$NUTS1, function(idx) {
  qri(y = synthouse$eq_income[idx],
      weights = synthouse$weight[idx],
      type = 6)
})

# Compare multiple indicators
compare_regions <- function(region_data, region_weights) {
  c(
    QRI = qri(region_data, region_weights),
    QSR = qsr(region_data, region_weights),
    Palma = palma_ratio(region_data, region_weights),
    P90_P10 = ratio_quantiles(region_data, region_weights)
  )
}

# Apply to each region
results_by_region <- tapply(seq_len(nrow(synthouse)), 
                             synthouse$NUTS1, 
                             function(idx) {
  compare_regions(synthouse$eq_income[idx], 
                  synthouse$weight[idx])
})

# Display as data frame
do.call(rbind, results_by_region)
```

# Grouped Data Functions

When only frequency tables are available (common with administrative or tax data), the package provides specialized functions.

## QRI for Grouped Data

```{r}
# Example: Income distribution in frequency table format
income_freq <- c(120, 180, 150, 80, 40, 20, 10)
income_tot <- c(18800, 16300, 44700, 33900, 21500, 22100, 98300)
income_lower <- c(0, 15000, 30000, 45000, 60000, 80000, 100000)
income_upper <- c(15000, 30000, 45000, 60000, 80000, 100000, 150000)

# Compute QRI from grouped data
qri_grouped(freq = income_freq, 
            lower_bounds = income_lower, 
            upper_bounds = income_upper)
```

## Quantiles from Grouped Data

```{r}
# Estimate quantiles from grouped data
quantile_grouped(freq = income_freq,
                 lower_bounds = income_lower,
                 upper_bounds = income_upper,
                 probs = c(0.25, 0.5, 0.75))
```
## Gini coefficient from Grouped Data

```{r}
# Estimate quantiles from grouped data
gini_grouped(Y = income_tot, freq = income_freq)
```

## Handling Open-Ended Classes

The functions automatically handle open-ended classes (common in tax data):

```{r}
# Example with open-ended classes
wage_freq <- c(150, 200, 180, 220, 180, 50, 15, 5)
wage_lower <- c(-Inf, 0, 10000, 15000, 26000, 55000, 75000, 120000)
wage_upper <- c(0, 10000, 15000, 26000, 55000, 75000, 120000, Inf)

# Compute QRI (automatically handles infinite bounds)
qri_grouped(freq = wage_freq, 
            lower_bounds = wage_lower, 
            upper_bounds = wage_upper)
```



# Variance Estimation and Inference

## Influence Functions

The package provides influence functions for constructing variance estimators using linearization methods:

### Influence Function for quantiles




## Influence Function for some inequality indicators

```{r}
# Select a subset for clearer visualization
n_obs <- 200
set.seed(123)
idx <- sample(nrow(synthouse), n_obs)

# Extract data
y_subset <- synthouse$eq_income[idx]
w_subset <- synthouse$weight[idx]

# Order income values (for ease of representation, see the plots later)
order_idx <- order(y_subset)
y_ordered <- y_subset[order_idx]      # Ordina i dati
w_ordered <- w_subset[order_idx]      

# Compute the IF for some indicators
if_gini_vals <- if_gini(y_ordered, w_ordered)
if_qri_vals <- if_qri(y_ordered, w_ordered, type = 6)
if_qsr_vals <- if_qsr(y_ordered, w_ordered, type = 4)
if_q50_vals <- if_quantile(y_ordered, w_ordered, probs = 0.5, type = 6)

```
### Comparison of the influence function values

```{r}
# Create the plot
library(ggplot2)
library(scales)

# 
plot_df <- data.frame(
  Income = rep(y_ordered, 4),
  IF_Value = c(
    if_qri_vals,   # ← Già ordinato
    if_qsr_vals,   # ← Già ordinato
    if_gini_vals,  # ← Già ordinato
    if_q50_vals    # ← Già ordinato
  ),
  Indicator = rep(c("QRI", "QSR", "Gini", "Median"), each = n_obs)
)

ggplot(plot_df, aes(x = Income, y = IF_Value, color = Indicator)) +
  geom_line(linewidth = 0.8, alpha = 0.7) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray40") +
  facet_wrap(~ Indicator, scales = "free_y", ncol = 2) +
  scale_x_continuous(labels = scales::comma) +
  labs(
    title = "Influence Functions: How Each Observation Affects the Estimate",
    subtitle = paste("Based on", n_obs, "randomly sampled households"),
    x = "Equivalized Income (ordered)",
    y = "Influence Function Value",
    caption = "Note: Higher absolute values indicate greater influence on the estimate"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 11),
    plot.title = element_text(face = "bold", size = 13),
    plot.subtitle = element_text(color = "gray40"),
    panel.grid.minor = element_blank()
  )
```

#### Key Observations

**Gini Coefficient**:
- Shows generally increasing pattern with income
- Negative values for low incomes, positive for high incomes

**QRI (Quantile Ratio Index)**:
- Balanced influence across the entire distribution
- Jump around the median
- More robust than the other inequality indicators

**QSR (Quintile Share Ratio)**:
- Sharp discontinuities at $Q(0.2)$ and $Q(0.8)$
- Near-zero influence in the middle 60% of distribution
- High sensitivity to observations at boundary quantiles

**Median**:
- Step function that admits only two values
- Most robust but ignores most of the distribution


## Bootstrap Variance Estimation

For complex surveys, the rescaled bootstrap method \insertCite{rao1988resampling}{inequantiles}; \insertCite{rao1992some}{inequantiles} is recommended:

```{r, eval = FALSE}
# Pseudo-code for rescaled bootstrap for the estimation of the sampling variance of the QRI estimator
var_qri <- rescaled_bootstrap(
  data = synthouse,
  y = "eq_income",
  strata = "NUTS2",
  psu = "municipality",
  weights = "weight",
  estimator = function(x, w) qri(y = x, weights = w, type = 6),
  by_strata = TRUE,
  B = 100,
  seed = 456)
```


## Getting Help

If you encounter issues or have questions:

- Open an issue on [GitHub](https://github.com/silviascarpa/inequantiles/issues)
- Check the function documentation: `?qri`, `?csquantile`, etc.
- Contact the maintainer: silvia.scarpa@unimore.it


# References

\insertRef{harrell1982new}{inequantiles}

\insertRef{rao1988resampling}{inequantiles}

\insertRef{rao1992some}{inequantiles}

\insertRef{hyndman1996sample}{inequantiles}

\insertRef{prendergast2018simple}{inequantiles}

\insertRef{scarpa2025inference}{inequantiles}


# Session Info

```{r}
sessionInfo()
```
